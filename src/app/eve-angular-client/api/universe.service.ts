/**
 * EVE Swagger Interface
 * An OpenAPI for EVE Online
 *
 * OpenAPI spec version: 0.8.4
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

// import { Observable }                                        from 'rxjs/Observable';
import { Observable } from 'rxjs';

import { BadRequest } from '../model/badRequest';
import { ErrorLimited } from '../model/errorLimited';
import { Forbidden } from '../model/forbidden';
import { GatewayTimeout } from '../model/gatewayTimeout';
import { GetUniverseAncestries200Ok } from '../model/getUniverseAncestries200Ok';
import { GetUniverseAsteroidBeltsAsteroidBeltIdNotFound } from '../model/getUniverseAsteroidBeltsAsteroidBeltIdNotFound';
import { GetUniverseAsteroidBeltsAsteroidBeltIdOk } from '../model/getUniverseAsteroidBeltsAsteroidBeltIdOk';
import { GetUniverseBloodlines200Ok } from '../model/getUniverseBloodlines200Ok';
import { GetUniverseCategoriesCategoryIdNotFound } from '../model/getUniverseCategoriesCategoryIdNotFound';
import { GetUniverseCategoriesCategoryIdOk } from '../model/getUniverseCategoriesCategoryIdOk';
import { GetUniverseConstellationsConstellationIdNotFound } from '../model/getUniverseConstellationsConstellationIdNotFound';
import { GetUniverseConstellationsConstellationIdOk } from '../model/getUniverseConstellationsConstellationIdOk';
import { GetUniverseFactions200Ok } from '../model/getUniverseFactions200Ok';
import { GetUniverseGraphicsGraphicIdNotFound } from '../model/getUniverseGraphicsGraphicIdNotFound';
import { GetUniverseGraphicsGraphicIdOk } from '../model/getUniverseGraphicsGraphicIdOk';
import { GetUniverseGroupsGroupIdNotFound } from '../model/getUniverseGroupsGroupIdNotFound';
import { GetUniverseGroupsGroupIdOk } from '../model/getUniverseGroupsGroupIdOk';
import { GetUniverseMoonsMoonIdNotFound } from '../model/getUniverseMoonsMoonIdNotFound';
import { GetUniverseMoonsMoonIdOk } from '../model/getUniverseMoonsMoonIdOk';
import { GetUniversePlanetsPlanetIdNotFound } from '../model/getUniversePlanetsPlanetIdNotFound';
import { GetUniversePlanetsPlanetIdOk } from '../model/getUniversePlanetsPlanetIdOk';
import { GetUniverseRaces200Ok } from '../model/getUniverseRaces200Ok';
import { GetUniverseRegionsRegionIdNotFound } from '../model/getUniverseRegionsRegionIdNotFound';
import { GetUniverseRegionsRegionIdOk } from '../model/getUniverseRegionsRegionIdOk';
import { GetUniverseStargatesStargateIdNotFound } from '../model/getUniverseStargatesStargateIdNotFound';
import { GetUniverseStargatesStargateIdOk } from '../model/getUniverseStargatesStargateIdOk';
import { GetUniverseStarsStarIdOk } from '../model/getUniverseStarsStarIdOk';
import { GetUniverseStationsStationIdNotFound } from '../model/getUniverseStationsStationIdNotFound';
import { GetUniverseStationsStationIdOk } from '../model/getUniverseStationsStationIdOk';
import { GetUniverseStructuresStructureIdNotFound } from '../model/getUniverseStructuresStructureIdNotFound';
import { GetUniverseStructuresStructureIdOk } from '../model/getUniverseStructuresStructureIdOk';
import { GetUniverseSystemJumps200Ok } from '../model/getUniverseSystemJumps200Ok';
import { GetUniverseSystemKills200Ok } from '../model/getUniverseSystemKills200Ok';
import { GetUniverseSystemsSystemIdNotFound } from '../model/getUniverseSystemsSystemIdNotFound';
import { GetUniverseSystemsSystemIdOk } from '../model/getUniverseSystemsSystemIdOk';
import { GetUniverseTypesTypeIdNotFound } from '../model/getUniverseTypesTypeIdNotFound';
import { GetUniverseTypesTypeIdOk } from '../model/getUniverseTypesTypeIdOk';
import { InternalServerError } from '../model/internalServerError';
import { PostUniverseIdsOk } from '../model/postUniverseIdsOk';
import { PostUniverseNames200Ok } from '../model/postUniverseNames200Ok';
import { PostUniverseNamesNotFound } from '../model/postUniverseNamesNotFound';
import { ServiceUnavailable } from '../model/serviceUnavailable';
import { Unauthorized } from '../model/unauthorized';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable()
export class UniverseService {

    protected basePath = 'https://esi.evetech.net';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (let consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * Get ancestries
     * Get all character ancestries  ---  This route expires daily at 11:05
     * @param acceptLanguage Language to use in the response
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param language Language to use in the response, takes precedence over Accept-Language
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getUniverseAncestries(acceptLanguage?: string, datasource?: string, ifNoneMatch?: string, language?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<GetUniverseAncestries200Ok>>;
    public getUniverseAncestries(acceptLanguage?: string, datasource?: string, ifNoneMatch?: string, language?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<GetUniverseAncestries200Ok>>>;
    public getUniverseAncestries(acceptLanguage?: string, datasource?: string, ifNoneMatch?: string, language?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<GetUniverseAncestries200Ok>>>;
    public getUniverseAncestries(acceptLanguage?: string, datasource?: string, ifNoneMatch?: string, language?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (datasource !== undefined) {
            queryParameters = queryParameters.set('datasource', <any>datasource);
        }
        if (language !== undefined) {
            queryParameters = queryParameters.set('language', <any>language);
        }

        let headers = this.defaultHeaders;
        if (acceptLanguage !== undefined && acceptLanguage !== null) {
            headers = headers.set('Accept-Language', String(acceptLanguage));
        }
        if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
            headers = headers.set('If-None-Match', String(ifNoneMatch));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<GetUniverseAncestries200Ok>>(`${this.basePath}/v1/universe/ancestries/`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get asteroid belt information
     * Get information on an asteroid belt  ---  This route expires daily at 11:05
     * @param asteroidBeltId asteroid_belt_id integer
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getUniverseAsteroidBeltsAsteroidBeltId(asteroidBeltId: number, datasource?: string, ifNoneMatch?: string, observe?: 'body', reportProgress?: boolean): Observable<GetUniverseAsteroidBeltsAsteroidBeltIdOk>;
    public getUniverseAsteroidBeltsAsteroidBeltId(asteroidBeltId: number, datasource?: string, ifNoneMatch?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<GetUniverseAsteroidBeltsAsteroidBeltIdOk>>;
    public getUniverseAsteroidBeltsAsteroidBeltId(asteroidBeltId: number, datasource?: string, ifNoneMatch?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<GetUniverseAsteroidBeltsAsteroidBeltIdOk>>;
    public getUniverseAsteroidBeltsAsteroidBeltId(asteroidBeltId: number, datasource?: string, ifNoneMatch?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (asteroidBeltId === null || asteroidBeltId === undefined) {
            throw new Error('Required parameter asteroidBeltId was null or undefined when calling getUniverseAsteroidBeltsAsteroidBeltId.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (datasource !== undefined) {
            queryParameters = queryParameters.set('datasource', <any>datasource);
        }

        let headers = this.defaultHeaders;
        if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
            headers = headers.set('If-None-Match', String(ifNoneMatch));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<GetUniverseAsteroidBeltsAsteroidBeltIdOk>(`${this.basePath}/v1/universe/asteroid_belts/${encodeURIComponent(String(asteroidBeltId))}/`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get bloodlines
     * Get a list of bloodlines  ---  This route expires daily at 11:05
     * @param acceptLanguage Language to use in the response
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param language Language to use in the response, takes precedence over Accept-Language
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getUniverseBloodlines(acceptLanguage?: string, datasource?: string, ifNoneMatch?: string, language?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<GetUniverseBloodlines200Ok>>;
    public getUniverseBloodlines(acceptLanguage?: string, datasource?: string, ifNoneMatch?: string, language?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<GetUniverseBloodlines200Ok>>>;
    public getUniverseBloodlines(acceptLanguage?: string, datasource?: string, ifNoneMatch?: string, language?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<GetUniverseBloodlines200Ok>>>;
    public getUniverseBloodlines(acceptLanguage?: string, datasource?: string, ifNoneMatch?: string, language?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (datasource !== undefined) {
            queryParameters = queryParameters.set('datasource', <any>datasource);
        }
        if (language !== undefined) {
            queryParameters = queryParameters.set('language', <any>language);
        }

        let headers = this.defaultHeaders;
        if (acceptLanguage !== undefined && acceptLanguage !== null) {
            headers = headers.set('Accept-Language', String(acceptLanguage));
        }
        if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
            headers = headers.set('If-None-Match', String(ifNoneMatch));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<GetUniverseBloodlines200Ok>>(`${this.basePath}/v1/universe/bloodlines/`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get item categories
     * Get a list of item categories  ---  This route expires daily at 11:05
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getUniverseCategories(datasource?: string, ifNoneMatch?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<number>>;
    public getUniverseCategories(datasource?: string, ifNoneMatch?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<number>>>;
    public getUniverseCategories(datasource?: string, ifNoneMatch?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<number>>>;
    public getUniverseCategories(datasource?: string, ifNoneMatch?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (datasource !== undefined) {
            queryParameters = queryParameters.set('datasource', <any>datasource);
        }

        let headers = this.defaultHeaders;
        if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
            headers = headers.set('If-None-Match', String(ifNoneMatch));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<number>>(`${this.basePath}/v1/universe/categories/`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get item category information
     * Get information of an item category  ---  This route expires daily at 11:05
     * @param categoryId An Eve item category ID
     * @param acceptLanguage Language to use in the response
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param language Language to use in the response, takes precedence over Accept-Language
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getUniverseCategoriesCategoryId(categoryId: number, acceptLanguage?: string, datasource?: string, ifNoneMatch?: string, language?: string, observe?: 'body', reportProgress?: boolean): Observable<GetUniverseCategoriesCategoryIdOk>;
    public getUniverseCategoriesCategoryId(categoryId: number, acceptLanguage?: string, datasource?: string, ifNoneMatch?: string, language?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<GetUniverseCategoriesCategoryIdOk>>;
    public getUniverseCategoriesCategoryId(categoryId: number, acceptLanguage?: string, datasource?: string, ifNoneMatch?: string, language?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<GetUniverseCategoriesCategoryIdOk>>;
    public getUniverseCategoriesCategoryId(categoryId: number, acceptLanguage?: string, datasource?: string, ifNoneMatch?: string, language?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (categoryId === null || categoryId === undefined) {
            throw new Error('Required parameter categoryId was null or undefined when calling getUniverseCategoriesCategoryId.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (datasource !== undefined) {
            queryParameters = queryParameters.set('datasource', <any>datasource);
        }
        if (language !== undefined) {
            queryParameters = queryParameters.set('language', <any>language);
        }

        let headers = this.defaultHeaders;
        if (acceptLanguage !== undefined && acceptLanguage !== null) {
            headers = headers.set('Accept-Language', String(acceptLanguage));
        }
        if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
            headers = headers.set('If-None-Match', String(ifNoneMatch));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<GetUniverseCategoriesCategoryIdOk>(`${this.basePath}/v1/universe/categories/${encodeURIComponent(String(categoryId))}/`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get constellations
     * Get a list of constellations  ---  This route expires daily at 11:05
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getUniverseConstellations(datasource?: string, ifNoneMatch?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<number>>;
    public getUniverseConstellations(datasource?: string, ifNoneMatch?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<number>>>;
    public getUniverseConstellations(datasource?: string, ifNoneMatch?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<number>>>;
    public getUniverseConstellations(datasource?: string, ifNoneMatch?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (datasource !== undefined) {
            queryParameters = queryParameters.set('datasource', <any>datasource);
        }

        let headers = this.defaultHeaders;
        if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
            headers = headers.set('If-None-Match', String(ifNoneMatch));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<number>>(`${this.basePath}/v1/universe/constellations/`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get constellation information
     * Get information on a constellation  ---  This route expires daily at 11:05
     * @param constellationId constellation_id integer
     * @param acceptLanguage Language to use in the response
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param language Language to use in the response, takes precedence over Accept-Language
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getUniverseConstellationsConstellationId(constellationId: number, acceptLanguage?: string, datasource?: string, ifNoneMatch?: string, language?: string, observe?: 'body', reportProgress?: boolean): Observable<GetUniverseConstellationsConstellationIdOk>;
    public getUniverseConstellationsConstellationId(constellationId: number, acceptLanguage?: string, datasource?: string, ifNoneMatch?: string, language?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<GetUniverseConstellationsConstellationIdOk>>;
    public getUniverseConstellationsConstellationId(constellationId: number, acceptLanguage?: string, datasource?: string, ifNoneMatch?: string, language?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<GetUniverseConstellationsConstellationIdOk>>;
    public getUniverseConstellationsConstellationId(constellationId: number, acceptLanguage?: string, datasource?: string, ifNoneMatch?: string, language?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (constellationId === null || constellationId === undefined) {
            throw new Error('Required parameter constellationId was null or undefined when calling getUniverseConstellationsConstellationId.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (datasource !== undefined) {
            queryParameters = queryParameters.set('datasource', <any>datasource);
        }
        if (language !== undefined) {
            queryParameters = queryParameters.set('language', <any>language);
        }

        let headers = this.defaultHeaders;
        if (acceptLanguage !== undefined && acceptLanguage !== null) {
            headers = headers.set('Accept-Language', String(acceptLanguage));
        }
        if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
            headers = headers.set('If-None-Match', String(ifNoneMatch));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<GetUniverseConstellationsConstellationIdOk>(`${this.basePath}/v1/universe/constellations/${encodeURIComponent(String(constellationId))}/`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get factions
     * Get a list of factions  ---  This route expires daily at 11:05
     * @param acceptLanguage Language to use in the response
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param language Language to use in the response, takes precedence over Accept-Language
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getUniverseFactions(acceptLanguage?: string, datasource?: string, ifNoneMatch?: string, language?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<GetUniverseFactions200Ok>>;
    public getUniverseFactions(acceptLanguage?: string, datasource?: string, ifNoneMatch?: string, language?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<GetUniverseFactions200Ok>>>;
    public getUniverseFactions(acceptLanguage?: string, datasource?: string, ifNoneMatch?: string, language?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<GetUniverseFactions200Ok>>>;
    public getUniverseFactions(acceptLanguage?: string, datasource?: string, ifNoneMatch?: string, language?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (datasource !== undefined) {
            queryParameters = queryParameters.set('datasource', <any>datasource);
        }
        if (language !== undefined) {
            queryParameters = queryParameters.set('language', <any>language);
        }

        let headers = this.defaultHeaders;
        if (acceptLanguage !== undefined && acceptLanguage !== null) {
            headers = headers.set('Accept-Language', String(acceptLanguage));
        }
        if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
            headers = headers.set('If-None-Match', String(ifNoneMatch));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<GetUniverseFactions200Ok>>(`${this.basePath}/v2/universe/factions/`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get graphics
     * Get a list of graphics  ---  This route expires daily at 11:05
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getUniverseGraphics(datasource?: string, ifNoneMatch?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<number>>;
    public getUniverseGraphics(datasource?: string, ifNoneMatch?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<number>>>;
    public getUniverseGraphics(datasource?: string, ifNoneMatch?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<number>>>;
    public getUniverseGraphics(datasource?: string, ifNoneMatch?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (datasource !== undefined) {
            queryParameters = queryParameters.set('datasource', <any>datasource);
        }

        let headers = this.defaultHeaders;
        if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
            headers = headers.set('If-None-Match', String(ifNoneMatch));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<number>>(`${this.basePath}/v1/universe/graphics/`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get graphic information
     * Get information on a graphic  ---  This route expires daily at 11:05
     * @param graphicId graphic_id integer
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getUniverseGraphicsGraphicId(graphicId: number, datasource?: string, ifNoneMatch?: string, observe?: 'body', reportProgress?: boolean): Observable<GetUniverseGraphicsGraphicIdOk>;
    public getUniverseGraphicsGraphicId(graphicId: number, datasource?: string, ifNoneMatch?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<GetUniverseGraphicsGraphicIdOk>>;
    public getUniverseGraphicsGraphicId(graphicId: number, datasource?: string, ifNoneMatch?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<GetUniverseGraphicsGraphicIdOk>>;
    public getUniverseGraphicsGraphicId(graphicId: number, datasource?: string, ifNoneMatch?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (graphicId === null || graphicId === undefined) {
            throw new Error('Required parameter graphicId was null or undefined when calling getUniverseGraphicsGraphicId.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (datasource !== undefined) {
            queryParameters = queryParameters.set('datasource', <any>datasource);
        }

        let headers = this.defaultHeaders;
        if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
            headers = headers.set('If-None-Match', String(ifNoneMatch));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<GetUniverseGraphicsGraphicIdOk>(`${this.basePath}/v1/universe/graphics/${encodeURIComponent(String(graphicId))}/`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get item groups
     * Get a list of item groups  ---  This route expires daily at 11:05
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param page Which page of results to return
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getUniverseGroups(datasource?: string, ifNoneMatch?: string, page?: number, observe?: 'body', reportProgress?: boolean): Observable<Array<number>>;
    public getUniverseGroups(datasource?: string, ifNoneMatch?: string, page?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<number>>>;
    public getUniverseGroups(datasource?: string, ifNoneMatch?: string, page?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<number>>>;
    public getUniverseGroups(datasource?: string, ifNoneMatch?: string, page?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (datasource !== undefined) {
            queryParameters = queryParameters.set('datasource', <any>datasource);
        }
        if (page !== undefined) {
            queryParameters = queryParameters.set('page', <any>page);
        }

        let headers = this.defaultHeaders;
        if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
            headers = headers.set('If-None-Match', String(ifNoneMatch));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<number>>(`${this.basePath}/v1/universe/groups/`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get item group information
     * Get information on an item group  ---  This route expires daily at 11:05
     * @param groupId An Eve item group ID
     * @param acceptLanguage Language to use in the response
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param language Language to use in the response, takes precedence over Accept-Language
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getUniverseGroupsGroupId(groupId: number, acceptLanguage?: string, datasource?: string, ifNoneMatch?: string, language?: string, observe?: 'body', reportProgress?: boolean): Observable<GetUniverseGroupsGroupIdOk>;
    public getUniverseGroupsGroupId(groupId: number, acceptLanguage?: string, datasource?: string, ifNoneMatch?: string, language?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<GetUniverseGroupsGroupIdOk>>;
    public getUniverseGroupsGroupId(groupId: number, acceptLanguage?: string, datasource?: string, ifNoneMatch?: string, language?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<GetUniverseGroupsGroupIdOk>>;
    public getUniverseGroupsGroupId(groupId: number, acceptLanguage?: string, datasource?: string, ifNoneMatch?: string, language?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (groupId === null || groupId === undefined) {
            throw new Error('Required parameter groupId was null or undefined when calling getUniverseGroupsGroupId.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (datasource !== undefined) {
            queryParameters = queryParameters.set('datasource', <any>datasource);
        }
        if (language !== undefined) {
            queryParameters = queryParameters.set('language', <any>language);
        }

        let headers = this.defaultHeaders;
        if (acceptLanguage !== undefined && acceptLanguage !== null) {
            headers = headers.set('Accept-Language', String(acceptLanguage));
        }
        if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
            headers = headers.set('If-None-Match', String(ifNoneMatch));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<GetUniverseGroupsGroupIdOk>(`${this.basePath}/v1/universe/groups/${encodeURIComponent(String(groupId))}/`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get moon information
     * Get information on a moon  ---  This route expires daily at 11:05
     * @param moonId moon_id integer
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getUniverseMoonsMoonId(moonId: number, datasource?: string, ifNoneMatch?: string, observe?: 'body', reportProgress?: boolean): Observable<GetUniverseMoonsMoonIdOk>;
    public getUniverseMoonsMoonId(moonId: number, datasource?: string, ifNoneMatch?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<GetUniverseMoonsMoonIdOk>>;
    public getUniverseMoonsMoonId(moonId: number, datasource?: string, ifNoneMatch?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<GetUniverseMoonsMoonIdOk>>;
    public getUniverseMoonsMoonId(moonId: number, datasource?: string, ifNoneMatch?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (moonId === null || moonId === undefined) {
            throw new Error('Required parameter moonId was null or undefined when calling getUniverseMoonsMoonId.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (datasource !== undefined) {
            queryParameters = queryParameters.set('datasource', <any>datasource);
        }

        let headers = this.defaultHeaders;
        if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
            headers = headers.set('If-None-Match', String(ifNoneMatch));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<GetUniverseMoonsMoonIdOk>(`${this.basePath}/v1/universe/moons/${encodeURIComponent(String(moonId))}/`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get planet information
     * Get information on a planet  ---  This route expires daily at 11:05
     * @param planetId planet_id integer
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getUniversePlanetsPlanetId(planetId: number, datasource?: string, ifNoneMatch?: string, observe?: 'body', reportProgress?: boolean): Observable<GetUniversePlanetsPlanetIdOk>;
    public getUniversePlanetsPlanetId(planetId: number, datasource?: string, ifNoneMatch?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<GetUniversePlanetsPlanetIdOk>>;
    public getUniversePlanetsPlanetId(planetId: number, datasource?: string, ifNoneMatch?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<GetUniversePlanetsPlanetIdOk>>;
    public getUniversePlanetsPlanetId(planetId: number, datasource?: string, ifNoneMatch?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (planetId === null || planetId === undefined) {
            throw new Error('Required parameter planetId was null or undefined when calling getUniversePlanetsPlanetId.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (datasource !== undefined) {
            queryParameters = queryParameters.set('datasource', <any>datasource);
        }

        let headers = this.defaultHeaders;
        if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
            headers = headers.set('If-None-Match', String(ifNoneMatch));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<GetUniversePlanetsPlanetIdOk>(`${this.basePath}/v1/universe/planets/${encodeURIComponent(String(planetId))}/`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get character races
     * Get a list of character races  ---  This route expires daily at 11:05
     * @param acceptLanguage Language to use in the response
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param language Language to use in the response, takes precedence over Accept-Language
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getUniverseRaces(acceptLanguage?: string, datasource?: string, ifNoneMatch?: string, language?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<GetUniverseRaces200Ok>>;
    public getUniverseRaces(acceptLanguage?: string, datasource?: string, ifNoneMatch?: string, language?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<GetUniverseRaces200Ok>>>;
    public getUniverseRaces(acceptLanguage?: string, datasource?: string, ifNoneMatch?: string, language?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<GetUniverseRaces200Ok>>>;
    public getUniverseRaces(acceptLanguage?: string, datasource?: string, ifNoneMatch?: string, language?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (datasource !== undefined) {
            queryParameters = queryParameters.set('datasource', <any>datasource);
        }
        if (language !== undefined) {
            queryParameters = queryParameters.set('language', <any>language);
        }

        let headers = this.defaultHeaders;
        if (acceptLanguage !== undefined && acceptLanguage !== null) {
            headers = headers.set('Accept-Language', String(acceptLanguage));
        }
        if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
            headers = headers.set('If-None-Match', String(ifNoneMatch));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<GetUniverseRaces200Ok>>(`${this.basePath}/v1/universe/races/`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get regions
     * Get a list of regions  ---  This route expires daily at 11:05
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getUniverseRegions(datasource?: string, ifNoneMatch?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<number>>;
    public getUniverseRegions(datasource?: string, ifNoneMatch?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<number>>>;
    public getUniverseRegions(datasource?: string, ifNoneMatch?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<number>>>;
    public getUniverseRegions(datasource?: string, ifNoneMatch?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (datasource !== undefined) {
            queryParameters = queryParameters.set('datasource', <any>datasource);
        }

        let headers = this.defaultHeaders;
        if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
            headers = headers.set('If-None-Match', String(ifNoneMatch));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<number>>(`${this.basePath}/v1/universe/regions/`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get region information
     * Get information on a region  ---  This route expires daily at 11:05
     * @param regionId region_id integer
     * @param acceptLanguage Language to use in the response
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param language Language to use in the response, takes precedence over Accept-Language
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getUniverseRegionsRegionId(regionId: number, acceptLanguage?: string, datasource?: string, ifNoneMatch?: string, language?: string, observe?: 'body', reportProgress?: boolean): Observable<GetUniverseRegionsRegionIdOk>;
    public getUniverseRegionsRegionId(regionId: number, acceptLanguage?: string, datasource?: string, ifNoneMatch?: string, language?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<GetUniverseRegionsRegionIdOk>>;
    public getUniverseRegionsRegionId(regionId: number, acceptLanguage?: string, datasource?: string, ifNoneMatch?: string, language?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<GetUniverseRegionsRegionIdOk>>;
    public getUniverseRegionsRegionId(regionId: number, acceptLanguage?: string, datasource?: string, ifNoneMatch?: string, language?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (regionId === null || regionId === undefined) {
            throw new Error('Required parameter regionId was null or undefined when calling getUniverseRegionsRegionId.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (datasource !== undefined) {
            queryParameters = queryParameters.set('datasource', <any>datasource);
        }
        if (language !== undefined) {
            queryParameters = queryParameters.set('language', <any>language);
        }

        let headers = this.defaultHeaders;
        if (acceptLanguage !== undefined && acceptLanguage !== null) {
            headers = headers.set('Accept-Language', String(acceptLanguage));
        }
        if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
            headers = headers.set('If-None-Match', String(ifNoneMatch));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<GetUniverseRegionsRegionIdOk>(`${this.basePath}/v1/universe/regions/${encodeURIComponent(String(regionId))}/`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get stargate information
     * Get information on a stargate  ---  This route expires daily at 11:05
     * @param stargateId stargate_id integer
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getUniverseStargatesStargateId(stargateId: number, datasource?: string, ifNoneMatch?: string, observe?: 'body', reportProgress?: boolean): Observable<GetUniverseStargatesStargateIdOk>;
    public getUniverseStargatesStargateId(stargateId: number, datasource?: string, ifNoneMatch?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<GetUniverseStargatesStargateIdOk>>;
    public getUniverseStargatesStargateId(stargateId: number, datasource?: string, ifNoneMatch?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<GetUniverseStargatesStargateIdOk>>;
    public getUniverseStargatesStargateId(stargateId: number, datasource?: string, ifNoneMatch?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (stargateId === null || stargateId === undefined) {
            throw new Error('Required parameter stargateId was null or undefined when calling getUniverseStargatesStargateId.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (datasource !== undefined) {
            queryParameters = queryParameters.set('datasource', <any>datasource);
        }

        let headers = this.defaultHeaders;
        if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
            headers = headers.set('If-None-Match', String(ifNoneMatch));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<GetUniverseStargatesStargateIdOk>(`${this.basePath}/v1/universe/stargates/${encodeURIComponent(String(stargateId))}/`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get star information
     * Get information on a star  ---  This route expires daily at 11:05
     * @param starId star_id integer
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getUniverseStarsStarId(starId: number, datasource?: string, ifNoneMatch?: string, observe?: 'body', reportProgress?: boolean): Observable<GetUniverseStarsStarIdOk>;
    public getUniverseStarsStarId(starId: number, datasource?: string, ifNoneMatch?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<GetUniverseStarsStarIdOk>>;
    public getUniverseStarsStarId(starId: number, datasource?: string, ifNoneMatch?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<GetUniverseStarsStarIdOk>>;
    public getUniverseStarsStarId(starId: number, datasource?: string, ifNoneMatch?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (starId === null || starId === undefined) {
            throw new Error('Required parameter starId was null or undefined when calling getUniverseStarsStarId.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (datasource !== undefined) {
            queryParameters = queryParameters.set('datasource', <any>datasource);
        }

        let headers = this.defaultHeaders;
        if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
            headers = headers.set('If-None-Match', String(ifNoneMatch));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<GetUniverseStarsStarIdOk>(`${this.basePath}/v1/universe/stars/${encodeURIComponent(String(starId))}/`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get station information
     * Get information on a station  ---  This route expires daily at 11:05
     * @param stationId station_id integer
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getUniverseStationsStationId(stationId: number, datasource?: string, ifNoneMatch?: string, observe?: 'body', reportProgress?: boolean): Observable<GetUniverseStationsStationIdOk>;
    public getUniverseStationsStationId(stationId: number, datasource?: string, ifNoneMatch?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<GetUniverseStationsStationIdOk>>;
    public getUniverseStationsStationId(stationId: number, datasource?: string, ifNoneMatch?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<GetUniverseStationsStationIdOk>>;
    public getUniverseStationsStationId(stationId: number, datasource?: string, ifNoneMatch?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (stationId === null || stationId === undefined) {
            throw new Error('Required parameter stationId was null or undefined when calling getUniverseStationsStationId.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (datasource !== undefined) {
            queryParameters = queryParameters.set('datasource', <any>datasource);
        }

        let headers = this.defaultHeaders;
        if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
            headers = headers.set('If-None-Match', String(ifNoneMatch));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<GetUniverseStationsStationIdOk>(`${this.basePath}/v2/universe/stations/${encodeURIComponent(String(stationId))}/`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * List all public structures
     * List all public structures  ---  This route is cached for up to 3600 seconds
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getUniverseStructures(datasource?: string, ifNoneMatch?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<number>>;
    public getUniverseStructures(datasource?: string, ifNoneMatch?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<number>>>;
    public getUniverseStructures(datasource?: string, ifNoneMatch?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<number>>>;
    public getUniverseStructures(datasource?: string, ifNoneMatch?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (datasource !== undefined) {
            queryParameters = queryParameters.set('datasource', <any>datasource);
        }

        let headers = this.defaultHeaders;
        if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
            headers = headers.set('If-None-Match', String(ifNoneMatch));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<number>>(`${this.basePath}/v1/universe/structures/`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get structure information
     * Returns information on requested structure, if you are on the ACL. Otherwise, returns \&quot;Forbidden\&quot; for all inputs.  ---  This route is cached for up to 3600 seconds  --- Warning: This route has an upgrade available.  --- [Diff of the upcoming changes](https://esi.evetech.net/diff/latest/dev/#GET-/universe/structures/{structure_id}/)
     * @param structureId An Eve structure ID
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param token Access token to use if unable to set a header
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getUniverseStructuresStructureId(structureId: number, datasource?: string, ifNoneMatch?: string, token?: string, observe?: 'body', reportProgress?: boolean): Observable<GetUniverseStructuresStructureIdOk>;
    public getUniverseStructuresStructureId(structureId: number, datasource?: string, ifNoneMatch?: string, token?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<GetUniverseStructuresStructureIdOk>>;
    public getUniverseStructuresStructureId(structureId: number, datasource?: string, ifNoneMatch?: string, token?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<GetUniverseStructuresStructureIdOk>>;
    public getUniverseStructuresStructureId(structureId: number, datasource?: string, ifNoneMatch?: string, token?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (structureId === null || structureId === undefined) {
            throw new Error('Required parameter structureId was null or undefined when calling getUniverseStructuresStructureId.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (datasource !== undefined) {
            queryParameters = queryParameters.set('datasource', <any>datasource);
        }
        if (token !== undefined) {
            queryParameters = queryParameters.set('token', <any>token);
        }

        let headers = this.defaultHeaders;
        if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
            headers = headers.set('If-None-Match', String(ifNoneMatch));
        }

        // authentication (evesso) required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<GetUniverseStructuresStructureIdOk>(`${this.basePath}/v1/universe/structures/${encodeURIComponent(String(structureId))}/`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get system jumps
     * Get the number of jumps in solar systems within the last hour ending at the timestamp of the Last-Modified header, excluding wormhole space. Only systems with jumps will be listed  ---  This route is cached for up to 3600 seconds
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getUniverseSystemJumps(datasource?: string, ifNoneMatch?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<GetUniverseSystemJumps200Ok>>;
    public getUniverseSystemJumps(datasource?: string, ifNoneMatch?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<GetUniverseSystemJumps200Ok>>>;
    public getUniverseSystemJumps(datasource?: string, ifNoneMatch?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<GetUniverseSystemJumps200Ok>>>;
    public getUniverseSystemJumps(datasource?: string, ifNoneMatch?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (datasource !== undefined) {
            queryParameters = queryParameters.set('datasource', <any>datasource);
        }

        let headers = this.defaultHeaders;
        if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
            headers = headers.set('If-None-Match', String(ifNoneMatch));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<GetUniverseSystemJumps200Ok>>(`${this.basePath}/v1/universe/system_jumps/`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get system kills
     * Get the number of ship, pod and NPC kills per solar system within the last hour ending at the timestamp of the Last-Modified header, excluding wormhole space. Only systems with kills will be listed  ---  This route is cached for up to 3600 seconds
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getUniverseSystemKills(datasource?: string, ifNoneMatch?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<GetUniverseSystemKills200Ok>>;
    public getUniverseSystemKills(datasource?: string, ifNoneMatch?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<GetUniverseSystemKills200Ok>>>;
    public getUniverseSystemKills(datasource?: string, ifNoneMatch?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<GetUniverseSystemKills200Ok>>>;
    public getUniverseSystemKills(datasource?: string, ifNoneMatch?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (datasource !== undefined) {
            queryParameters = queryParameters.set('datasource', <any>datasource);
        }

        let headers = this.defaultHeaders;
        if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
            headers = headers.set('If-None-Match', String(ifNoneMatch));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<GetUniverseSystemKills200Ok>>(`${this.basePath}/v2/universe/system_kills/`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get solar systems
     * Get a list of solar systems  ---  This route expires daily at 11:05
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getUniverseSystems(datasource?: string, ifNoneMatch?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<number>>;
    public getUniverseSystems(datasource?: string, ifNoneMatch?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<number>>>;
    public getUniverseSystems(datasource?: string, ifNoneMatch?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<number>>>;
    public getUniverseSystems(datasource?: string, ifNoneMatch?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (datasource !== undefined) {
            queryParameters = queryParameters.set('datasource', <any>datasource);
        }

        let headers = this.defaultHeaders;
        if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
            headers = headers.set('If-None-Match', String(ifNoneMatch));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<number>>(`${this.basePath}/v1/universe/systems/`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get solar system information
     * Get information on a solar system. NOTE: This route does not work with abyssal systems.  ---  This route expires daily at 11:05  --- Warning: This route has an upgrade available.  --- [Diff of the upcoming changes](https://esi.evetech.net/diff/latest/dev/#GET-/universe/systems/{system_id}/)
     * @param systemId system_id integer
     * @param acceptLanguage Language to use in the response
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param language Language to use in the response, takes precedence over Accept-Language
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getUniverseSystemsSystemId(systemId: number, acceptLanguage?: string, datasource?: string, ifNoneMatch?: string, language?: string, observe?: 'body', reportProgress?: boolean): Observable<GetUniverseSystemsSystemIdOk>;
    public getUniverseSystemsSystemId(systemId: number, acceptLanguage?: string, datasource?: string, ifNoneMatch?: string, language?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<GetUniverseSystemsSystemIdOk>>;
    public getUniverseSystemsSystemId(systemId: number, acceptLanguage?: string, datasource?: string, ifNoneMatch?: string, language?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<GetUniverseSystemsSystemIdOk>>;
    public getUniverseSystemsSystemId(systemId: number, acceptLanguage?: string, datasource?: string, ifNoneMatch?: string, language?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (systemId === null || systemId === undefined) {
            throw new Error('Required parameter systemId was null or undefined when calling getUniverseSystemsSystemId.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (datasource !== undefined) {
            queryParameters = queryParameters.set('datasource', <any>datasource);
        }
        if (language !== undefined) {
            queryParameters = queryParameters.set('language', <any>language);
        }

        let headers = this.defaultHeaders;
        if (acceptLanguage !== undefined && acceptLanguage !== null) {
            headers = headers.set('Accept-Language', String(acceptLanguage));
        }
        if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
            headers = headers.set('If-None-Match', String(ifNoneMatch));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<GetUniverseSystemsSystemIdOk>(`${this.basePath}/v3/universe/systems/${encodeURIComponent(String(systemId))}/`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get types
     * Get a list of type ids  ---  This route expires daily at 11:05
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param page Which page of results to return
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getUniverseTypes(datasource?: string, ifNoneMatch?: string, page?: number, observe?: 'body', reportProgress?: boolean): Observable<Array<number>>;
    public getUniverseTypes(datasource?: string, ifNoneMatch?: string, page?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<number>>>;
    public getUniverseTypes(datasource?: string, ifNoneMatch?: string, page?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<number>>>;
    public getUniverseTypes(datasource?: string, ifNoneMatch?: string, page?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (datasource !== undefined) {
            queryParameters = queryParameters.set('datasource', <any>datasource);
        }
        if (page !== undefined) {
            queryParameters = queryParameters.set('page', <any>page);
        }

        let headers = this.defaultHeaders;
        if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
            headers = headers.set('If-None-Match', String(ifNoneMatch));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<number>>(`${this.basePath}/v1/universe/types/`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get type information
     * Get information on a type  ---  This route expires daily at 11:05
     * @param typeId An Eve item type ID
     * @param acceptLanguage Language to use in the response
     * @param datasource The server name you would like data from
     * @param ifNoneMatch ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param language Language to use in the response, takes precedence over Accept-Language
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getUniverseTypesTypeId(typeId: number, acceptLanguage?: string, datasource?: string, ifNoneMatch?: string, language?: string, observe?: 'body', reportProgress?: boolean): Observable<GetUniverseTypesTypeIdOk>;
    public getUniverseTypesTypeId(typeId: number, acceptLanguage?: string, datasource?: string, ifNoneMatch?: string, language?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<GetUniverseTypesTypeIdOk>>;
    public getUniverseTypesTypeId(typeId: number, acceptLanguage?: string, datasource?: string, ifNoneMatch?: string, language?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<GetUniverseTypesTypeIdOk>>;
    public getUniverseTypesTypeId(typeId: number, acceptLanguage?: string, datasource?: string, ifNoneMatch?: string, language?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (typeId === null || typeId === undefined) {
            throw new Error('Required parameter typeId was null or undefined when calling getUniverseTypesTypeId.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (datasource !== undefined) {
            queryParameters = queryParameters.set('datasource', <any>datasource);
        }
        if (language !== undefined) {
            queryParameters = queryParameters.set('language', <any>language);
        }

        let headers = this.defaultHeaders;
        if (acceptLanguage !== undefined && acceptLanguage !== null) {
            headers = headers.set('Accept-Language', String(acceptLanguage));
        }
        if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
            headers = headers.set('If-None-Match', String(ifNoneMatch));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<GetUniverseTypesTypeIdOk>(`${this.basePath}/v3/universe/types/${encodeURIComponent(String(typeId))}/`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Bulk names to IDs
     * Resolve a set of names to IDs in the following categories: agents, alliances, characters, constellations, corporations factions, inventory_types, regions, stations, and systems. Only exact matches will be returned. All names searched for are cached for 12 hours.  --- 
     * @param names The names to resolve
     * @param acceptLanguage Language to use in the response
     * @param datasource The server name you would like data from
     * @param language Language to use in the response, takes precedence over Accept-Language
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public postUniverseIds(names: Array<string>, acceptLanguage?: string, datasource?: string, language?: string, observe?: 'body', reportProgress?: boolean): Observable<PostUniverseIdsOk>;
    public postUniverseIds(names: Array<string>, acceptLanguage?: string, datasource?: string, language?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<PostUniverseIdsOk>>;
    public postUniverseIds(names: Array<string>, acceptLanguage?: string, datasource?: string, language?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PostUniverseIdsOk>>;
    public postUniverseIds(names: Array<string>, acceptLanguage?: string, datasource?: string, language?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (names === null || names === undefined) {
            throw new Error('Required parameter names was null or undefined when calling postUniverseIds.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (datasource !== undefined) {
            queryParameters = queryParameters.set('datasource', <any>datasource);
        }
        if (language !== undefined) {
            queryParameters = queryParameters.set('language', <any>language);
        }

        let headers = this.defaultHeaders;
        if (acceptLanguage !== undefined && acceptLanguage !== null) {
            headers = headers.set('Accept-Language', String(acceptLanguage));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.post<PostUniverseIdsOk>(`${this.basePath}/v1/universe/ids/`,
            names,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get names and categories for a set of ID&#39;s
     * Resolve a set of IDs to names and categories. Supported ID&#39;s for resolving are: Characters, Corporations, Alliances, Stations, Solar Systems, Constellations, Regions, Types.  --- 
     * @param ids The ids to resolve
     * @param datasource The server name you would like data from
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public postUniverseNames(ids: Array<number>, datasource?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<PostUniverseNames200Ok>>;
    public postUniverseNames(ids: Array<number>, datasource?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<PostUniverseNames200Ok>>>;
    public postUniverseNames(ids: Array<number>, datasource?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<PostUniverseNames200Ok>>>;
    public postUniverseNames(ids: Array<number>, datasource?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (ids === null || ids === undefined) {
            throw new Error('Required parameter ids was null or undefined when calling postUniverseNames.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (datasource !== undefined) {
            queryParameters = queryParameters.set('datasource', <any>datasource);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.post<Array<PostUniverseNames200Ok>>(`${this.basePath}/v2/universe/names/`,
            ids,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
